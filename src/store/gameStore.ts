/**
 * Zustand store for game state management
 */

import { create } from 'zustand';
import type { Tile, TerrainType, ZoneType, ZoneDensity, PowerPlant, WaterPump, GridPosition, PoliceStation } from '@/types';
import { MAP_SIZE } from '@/types';
import { disasterSystem, type DisasterType, type ActiveDisaster } from '@/systems';

// =============================================================================
// Game Constants
// =============================================================================

/** Initial budget for the player */
export const INITIAL_BUDGET = 50000;

/** Cost to place a low density zone tile */
export const ZONE_COST = 100;

/** Cost to place a medium density zone tile */
export const ZONE_COST_MEDIUM = 200;

/** Cost to place a road tile */
export const ROAD_COST = 20;

/** Cost to place a power plant */
export const POWER_PLANT_COST = 5000;

/** Power plant capacity in MW */
export const POWER_PLANT_CAPACITY = 400;

/** Cost to place a power line tile */
export const POWER_LINE_COST = 5;

/** Range of power from power lines (in tiles) */
export const POWER_RANGE = 6;

/** Cost to place a water pump */
export const WATER_PUMP_COST = 3000;

/** Water pump capacity in gallons/day */
export const WATER_PUMP_CAPACITY = 500;

/** Cost to place a water pipe tile */
export const WATER_PIPE_COST = 3;

/** Range of water service from water pipes (in tiles) */
export const WATER_RANGE = 6;

/** Cost to bulldoze a tile */
export const BULLDOZE_COST = 5;

/** Cost to place a police station */
export const POLICE_STATION_COST = 500;

/** Monthly maintenance cost per police station */
export const POLICE_STATION_MAINTENANCE_COST = 50;

/** Coverage radius of a police station (in tiles) */
export const POLICE_COVERAGE_RADIUS = 8;

/** Crime reduction factor within police coverage (80% reduction) */
export const POLICE_CRIME_REDUCTION = 0.8;

// =============================================================================
// Pollution Constants
// =============================================================================

/** Base pollution generated by a developed industrial tile (50-100 based on jobs) */
export const BASE_INDUSTRIAL_POLLUTION = 50;

/** Maximum pollution value per tile (cap) */
export const MAX_POLLUTION = 100;

/** Range of pollution spread from industrial zones (in tiles) */
export const POLLUTION_SPREAD_RADIUS = 6;

/** Pollution factor that reduces residential development speed (per pollution point) */
export const POLLUTION_DEVELOPMENT_PENALTY = 0.005; // 0.5% slower per pollution point

// =============================================================================
// Abandonment Constants
// =============================================================================

/** Number of consecutive months without power before a building becomes abandoned */
export const ABANDONMENT_MONTHS_NO_POWER = 3;

/** Number of consecutive months without water before a building becomes abandoned */
export const ABANDONMENT_MONTHS_NO_WATER = 3;

/** Number of consecutive months with high crime (>80) before a building becomes abandoned */
export const ABANDONMENT_MONTHS_HIGH_CRIME = 3;

/** Number of consecutive months with high pollution (>80) before a residential building becomes abandoned */
export const ABANDONMENT_MONTHS_HIGH_POLLUTION = 3;

/** Crime level threshold for abandonment (above this triggers counter) */
export const ABANDONMENT_CRIME_THRESHOLD = 80;

/** Pollution level threshold for abandonment (above this triggers counter for residential) */
export const ABANDONMENT_POLLUTION_THRESHOLD = 80;

// =============================================================================
// Budget Constants (from simulation-spec.md)
// =============================================================================

/** Tax revenue per person per month */
export const TAX_RATE_PER_PERSON = 10;

/** Monthly maintenance cost per road tile */
export const ROAD_MAINTENANCE_COST = 1;

/** Monthly maintenance cost per power plant */
export const POWER_PLANT_MAINTENANCE_COST = 100;

/** Monthly maintenance cost per water pump */
export const WATER_PUMP_MAINTENANCE_COST = 50;

// =============================================================================
// Simulation Constants (from simulation-spec.md)
// =============================================================================

/** Base development progress per month (10%) */
export const BASE_DEVELOPMENT_PROGRESS = 10;

/** Population capacity for low-density residential (per tile): 10-50 */
export const RESIDENTIAL_CAPACITY_LOW = 50;

/** Population capacity for medium-density residential (per tile): 20-100 */
export const RESIDENTIAL_CAPACITY_MEDIUM = 100;

/** Jobs for low-density commercial (per tile): 5-25 */
export const COMMERCIAL_JOBS_LOW = 25;

/** Jobs for medium-density commercial (per tile): 10-50 */
export const COMMERCIAL_JOBS_MEDIUM = 50;

/** Jobs for low-density industrial (per tile): 10-40 */
export const INDUSTRIAL_JOBS_LOW = 30;

/** Jobs for medium-density industrial (per tile): 20-80 */
export const INDUSTRIAL_JOBS_MEDIUM = 80;

/** Population threshold to unlock medium density */
export const MEDIUM_DENSITY_UNLOCK_POPULATION = 500;

// =============================================================================
// Milestone Constants
// =============================================================================

/** Population milestones that trigger notifications */
export const MILESTONES = [100, 500, 1000, 2000, 5000, 10000] as const;

// =============================================================================
// Demand System Constants (from simulation-spec.md and task spec)
// =============================================================================

/** Base residential demand */
export const BASE_RESIDENTIAL_DEMAND = 50;

/** Base commercial demand */
export const BASE_COMMERCIAL_DEMAND = 30;

/** Base industrial demand */
export const BASE_INDUSTRIAL_DEMAND = 40;

/** High demand threshold */
export const HIGH_DEMAND_THRESHOLD = 70;

/** Low demand threshold */
export const LOW_DEMAND_THRESHOLD = 30;

/** Demand multiplier for high demand (>70) - 50% faster */
export const HIGH_DEMAND_MULTIPLIER = 1.5;

/** Demand multiplier for low demand (<30) - 50% slower */
export const LOW_DEMAND_MULTIPLIER = 0.5;

// =============================================================================
// Store Types
// =============================================================================

/**
 * Demand values for each zone type (0-100)
 */
export interface DemandState {
  /** Residential demand (0-100) */
  residential: number;
  /** Commercial demand (0-100) */
  commercial: number;
  /** Industrial demand (0-100) */
  industrial: number;
}

/**
 * Unlocked features based on population milestones
 */
export interface UnlockedFeatures {
  /** Medium density zones unlocked at 500 population */
  mediumDensity: boolean;
}

/**
 * Monthly budget breakdown for UI display
 */
export interface MonthlyBudgetBreakdown {
  /** Total tax revenue from population */
  taxRevenue: number;
  /** Road maintenance costs */
  roadMaintenance: number;
  /** Power plant maintenance costs */
  powerMaintenance: number;
  /** Water pump maintenance costs */
  waterMaintenance: number;
  /** Police station maintenance costs */
  policeMaintenance: number;
  /** Total monthly expenses */
  totalExpenses: number;
  /** Net change (revenue - expenses) */
  netChange: number;
}

/**
 * Budget deficit event types for notifications
 */
export type BudgetDeficitEvent = 'entered_deficit' | 'still_in_deficit' | null;

/**
 * Disaster event that occurred this tick (for notifications)
 */
export interface DisasterEvent {
  type: DisasterType;
  damage: {
    tilesDestroyed: number;
    populationLost: number;
    jobsLost: number;
    infrastructureDestroyed: number;
  };
}

/**
 * Abandonment event for notifications
 */
export interface AbandonmentEvent {
  /** Position of the abandoned building */
  x: number;
  y: number;
  /** Type of zone that was abandoned */
  zoneType: 'residential' | 'commercial' | 'industrial';
  /** Reason for abandonment */
  reason: 'no_power' | 'no_water' | 'high_crime' | 'high_pollution';
}

export interface GameState {
  /** 2D array of tiles [y][x] - row-major order */
  tiles: Tile[][];
  /** Whether the map has been initialized */
  isInitialized: boolean;
  /** Player's current budget */
  budget: number;
  /** List of power plants on the map */
  powerPlants: PowerPlant[];
  /** List of water pumps on the map */
  waterPumps: WaterPump[];
  /** List of police stations on the map */
  policeStations: PoliceStation[];
  /** Crime level per tile (tile key -> crime level 0-100) */
  crimeMap: Map<string, number>;
  /** Pollution level per tile (tile key -> pollution level 0-100) */
  pollutionMap: Map<string, number>;
  /** Current game year (starts at 1) */
  gameYear: number;
  /** Current game month (1-12) */
  gameMonth: number;
  /** Total city population */
  population: number;
  /** Total commercial jobs in the city */
  commercialJobs: number;
  /** Total industrial jobs in the city */
  industrialJobs: number;
  /** Demand values for R/C/I zones */
  demand: DemandState;
  /** Population milestones that have been reached */
  milestonesReached: number[];
  /** Features unlocked through gameplay */
  unlockedFeatures: UnlockedFeatures;
  /** Monthly revenue from taxes */
  monthlyRevenue: number;
  /** Monthly expenses for maintenance */
  monthlyExpenses: number;
  /** Last budget change (revenue - expenses) */
  lastBudgetChange: number;
  /** Detailed budget breakdown for UI */
  budgetBreakdown: MonthlyBudgetBreakdown;
  /** Whether the city is currently in budget deficit */
  isInDeficit: boolean;
  /** Budget deficit event from last monthly calculation (for notifications) */
  lastDeficitEvent: BudgetDeficitEvent;
  /** Currently active disasters */
  activeDisasters: ActiveDisaster[];
  /** Tiles currently affected by disasters (for rendering) */
  disasterAffectedTiles: Map<string, DisasterType>;
  /** Last disaster event (for notifications) */
  lastDisasterEvent: DisasterEvent | null;
  /** Abandonment events from last monthly simulation (for notifications) */
  lastAbandonmentEvents: AbandonmentEvent[];
}

export interface GameActions {
  /** Initialize the map with random terrain */
  initializeMap: () => void;
  /** Get a specific tile by coordinates */
  getTile: (x: number, y: number) => Tile | null;
  /** Get all road tile positions for traffic system */
  getRoadTiles: () => GridPosition[];
  /** Get saveable game state data (without functions) */
  getSaveData: () => SaveableGameState;
  /** Check if a zone can be placed at the given coordinates */
  canPlaceZone: (x: number, y: number, density?: ZoneDensity) => boolean;
  /** Place a zone at the given coordinates */
  placeZone: (x: number, y: number, zoneType: ZoneType, density?: ZoneDensity) => boolean;
  /** Check if a road can be placed at the given coordinates */
  canPlaceRoad: (x: number, y: number) => boolean;
  /** Place a road at the given coordinates */
  placeRoad: (x: number, y: number) => boolean;
  /** Check if a tile has road access (adjacent road in N/S/E/W direction) */
  hasRoadAccess: (x: number, y: number) => boolean;
  /** Check if a power plant can be placed at the given coordinates */
  canPlacePowerPlant: (x: number, y: number) => boolean;
  /** Place a power plant at the given coordinates */
  placePowerPlant: (x: number, y: number) => boolean;
  /** Check if a power line can be placed at the given coordinates */
  canPlacePowerLine: (x: number, y: number) => boolean;
  /** Place a power line at the given coordinates */
  placePowerLine: (x: number, y: number) => boolean;
  /** Get power plant at a tile position (if any) */
  getPowerPlantAt: (x: number, y: number) => PowerPlant | null;
  /** Check if a tile has power */
  hasPower: (x: number, y: number) => boolean;
  /** Recalculate power grid distribution */
  calculatePowerGrid: () => void;
  /** Check if a water pump can be placed at the given coordinates */
  canPlaceWaterPump: (x: number, y: number) => boolean;
  /** Place a water pump at the given coordinates */
  placeWaterPump: (x: number, y: number) => boolean;
  /** Check if a water pipe can be placed at the given coordinates */
  canPlaceWaterPipe: (x: number, y: number) => boolean;
  /** Place a water pipe at the given coordinates */
  placeWaterPipe: (x: number, y: number) => boolean;
  /** Get water pump at a tile position (if any) */
  getWaterPumpAt: (x: number, y: number) => WaterPump | null;
  /** Check if a tile has water service */
  hasWater: (x: number, y: number) => boolean;
  /** Recalculate water grid distribution */
  calculateWaterGrid: () => void;
  /** Advance game time by one month */
  advanceMonth: () => void;
  /** Run the monthly simulation tick */
  runMonthlySimulation: () => void;
  /** Calculate and update demand values based on city state */
  calculateDemand: () => void;
  /** Check if any new milestones have been reached and return the newly reached milestone (or null) */
  checkMilestones: () => number | null;
  /** Calculate and apply monthly budget (revenue and expenses) */
  calculateMonthlyBudget: () => void;
  /** Check and return the last budget deficit event (and clear it) */
  checkBudgetDeficitEvent: () => BudgetDeficitEvent;
  /** Load game state from save data */
  loadSaveData: (saveData: SaveableGameState) => void;
  /** Check if a tile can be bulldozed (has something to remove) */
  canBulldoze: (x: number, y: number) => boolean;
  /** Bulldoze a tile - removes zone, building, road, power line, water pipe */
  bulldoze: (x: number, y: number) => boolean;
  /** Check for and potentially start a random disaster */
  checkForDisaster: () => DisasterType | null;
  /** Update active disasters and apply damage */
  updateDisasters: () => void;
  /** Get the last disaster event (and clear it) */
  getLastDisasterEvent: () => DisasterEvent | null;
  /** Get tiles affected by disasters (for rendering) */
  getDisasterAffectedTiles: () => Map<string, DisasterType>;
  /** Check if there are any active disasters */
  hasActiveDisasters: () => boolean;
  /** Check if a police station can be placed at the given coordinates */
  canPlacePoliceStation: (x: number, y: number) => boolean;
  /** Place a police station at the given coordinates */
  placePoliceStation: (x: number, y: number) => boolean;
  /** Get police station at a tile position (if any) */
  getPoliceStationAt: (x: number, y: number) => PoliceStation | null;
  /** Calculate and update crime levels across the city */
  calculateCrime: () => void;
  /** Get the crime level at a specific tile */
  getCrimeAt: (x: number, y: number) => number;
  /** Check if a tile has police coverage */
  hasPoliceCoverage: (x: number, y: number) => boolean;
  /** Calculate and update pollution levels across the city */
  calculatePollution: () => void;
  /** Get the pollution level at a specific tile */
  getPollutionAt: (x: number, y: number) => number;
  /** Get and clear the last abandonment events (for notifications) */
  getLastAbandonmentEvents: () => AbandonmentEvent[];
  /** Generate a random city for screensaver mode */
  generateRandomCity: () => void;
}

/**
 * Saveable game state (serializable data only, no functions)
 */
export interface SaveableGameState {
  tiles: Tile[][];
  powerPlants: PowerPlant[];
  waterPumps: WaterPump[];
  policeStations: PoliceStation[];
  budget: number;
  population: number;
  commercialJobs: number;
  industrialJobs: number;
  gameYear: number;
  gameMonth: number;
  demand: DemandState;
  milestonesReached: number[];
  unlockedFeatures: UnlockedFeatures;
}

export type GameStore = GameState & GameActions;

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Create an empty tile at the given coordinates
 */
function createTile(x: number, y: number, terrain: TerrainType = 'grass'): Tile {
  return {
    x,
    y,
    terrain,
    zone: null,
    // zoneDensity is optional, only set when a zone is placed
    hasRoad: false,
    hasPowerLine: false,
    hasWaterPipe: false,
    isPowered: false,
    hasWaterService: false,
    landValue: 50,
    developmentProgress: 0,
    population: 0,
    jobs: 0,
  };
}

/**
 * Generate random water bodies covering 10-15% of the map
 * Uses a simple blob/cluster algorithm for natural-looking water
 */
function generateWaterBodies(tiles: Tile[][]): void {
  const targetCoverage = 0.10 + Math.random() * 0.05; // 10-15%
  const totalTiles = MAP_SIZE * MAP_SIZE;
  const targetWaterTiles = Math.floor(totalTiles * targetCoverage);
  
  let waterTiles = 0;
  const maxSeeds = 8; // Maximum number of water body seed points
  const seeds: Array<{ x: number; y: number }> = [];
  
  // Generate seed points for water bodies
  for (let i = 0; i < maxSeeds && waterTiles < targetWaterTiles; i++) {
    const seedX = Math.floor(Math.random() * MAP_SIZE);
    const seedY = Math.floor(Math.random() * MAP_SIZE);
    seeds.push({ x: seedX, y: seedY });
    
    // Grow water blob from seed
    const blobSize = Math.floor(Math.random() * 50) + 20; // 20-70 tiles per blob
    const queue: Array<{ x: number; y: number }> = [{ x: seedX, y: seedY }];
    const visited = new Set<string>();
    
    while (queue.length > 0 && waterTiles < targetWaterTiles) {
      const current = queue.shift()!;
      const key = `${current.x},${current.y}`;
      
      if (visited.has(key)) continue;
      if (current.x < 0 || current.x >= MAP_SIZE) continue;
      if (current.y < 0 || current.y >= MAP_SIZE) continue;
      
      visited.add(key);
      
      const tile = tiles[current.y]?.[current.x];
      if (!tile || tile.terrain === 'water') continue;
      
      // Higher probability near center of blob
      const distFromSeed = Math.sqrt(
        Math.pow(current.x - seedX, 2) + Math.pow(current.y - seedY, 2)
      );
      const probability = Math.max(0.1, 1 - distFromSeed / 10);
      
      if (Math.random() < probability && visited.size < blobSize) {
        tile.terrain = 'water';
        waterTiles++;
        
        // Add neighbors to queue with some randomness
        const neighbors = [
          { x: current.x - 1, y: current.y },
          { x: current.x + 1, y: current.y },
          { x: current.x, y: current.y - 1 },
          { x: current.x, y: current.y + 1 },
        ];
        
        for (const neighbor of neighbors) {
          if (Math.random() < 0.7) { // 70% chance to expand in each direction
            queue.push(neighbor);
          }
        }
      }
    }
  }
}

/**
 * Initialize a new tile grid with random terrain
 */
function createInitialTileGrid(): Tile[][] {
  // Create empty grass grid
  const tiles: Tile[][] = [];
  
  for (let y = 0; y < MAP_SIZE; y++) {
    const row: Tile[] = [];
    for (let x = 0; x < MAP_SIZE; x++) {
      row.push(createTile(x, y, 'grass'));
    }
    tiles.push(row);
  }
  
  // Generate water bodies
  generateWaterBodies(tiles);
  
  return tiles;
}

// =============================================================================
// Store Definition
// =============================================================================

export const useGameStore = create<GameStore>((set, get) => ({
  // Initial state
  tiles: [],
  isInitialized: false,
  budget: INITIAL_BUDGET,
  powerPlants: [],
  waterPumps: [],
  policeStations: [],
  crimeMap: new Map(),
  pollutionMap: new Map(),
  gameYear: 1,
  gameMonth: 1,
  population: 0,
  commercialJobs: 0,
  industrialJobs: 0,
  demand: {
    residential: BASE_RESIDENTIAL_DEMAND,
    commercial: BASE_COMMERCIAL_DEMAND,
    industrial: BASE_INDUSTRIAL_DEMAND,
  },
  milestonesReached: [],
  unlockedFeatures: {
    mediumDensity: false,
  },
  monthlyRevenue: 0,
  monthlyExpenses: 0,
  lastBudgetChange: 0,
  budgetBreakdown: {
    taxRevenue: 0,
    roadMaintenance: 0,
    powerMaintenance: 0,
    waterMaintenance: 0,
    policeMaintenance: 0,
    totalExpenses: 0,
    netChange: 0,
  },
  isInDeficit: false,
  lastDeficitEvent: null,
  activeDisasters: [],
  disasterAffectedTiles: new Map(),
  lastDisasterEvent: null,
  lastAbandonmentEvents: [],
  
  // Actions
  initializeMap: () => {
    const tiles = createInitialTileGrid();
    // Clear any active disasters
    disasterSystem.clearAllDisasters();
    set({ 
      tiles, 
      isInitialized: true, 
      budget: INITIAL_BUDGET, 
      powerPlants: [], 
      waterPumps: [],
      policeStations: [],
      crimeMap: new Map(),
      pollutionMap: new Map(),
      gameYear: 1,
      gameMonth: 1,
      population: 0,
      commercialJobs: 0,
      industrialJobs: 0,
      demand: {
        residential: BASE_RESIDENTIAL_DEMAND,
        commercial: BASE_COMMERCIAL_DEMAND,
        industrial: BASE_INDUSTRIAL_DEMAND,
      },
      milestonesReached: [],
      unlockedFeatures: {
        mediumDensity: false,
      },
      monthlyRevenue: 0,
      monthlyExpenses: 0,
      lastBudgetChange: 0,
      budgetBreakdown: {
        taxRevenue: 0,
        roadMaintenance: 0,
        powerMaintenance: 0,
        waterMaintenance: 0,
        policeMaintenance: 0,
        totalExpenses: 0,
        netChange: 0,
      },
      isInDeficit: false,
      lastDeficitEvent: null,
      activeDisasters: [],
      disasterAffectedTiles: new Map(),
      lastDisasterEvent: null,
      lastAbandonmentEvents: [],
    });
  },
  
  getTile: (x: number, y: number) => {
    const { tiles } = get();
    if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) {
      return null;
    }
    return tiles[y]?.[x] ?? null;
  },
  
  getRoadTiles: () => {
    const { tiles } = get();
    const roadTiles: GridPosition[] = [];
    
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tile = tiles[y]?.[x];
        if (tile?.hasRoad) {
          roadTiles.push({ gridX: x, gridY: y });
        }
      }
    }
    
    return roadTiles;
  },
  
  canPlaceZone: (x: number, y: number, density: ZoneDensity = 'low') => {
    const { tiles, budget, unlockedFeatures } = get();
    
    // Check bounds
    if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) {
      return false;
    }
    
    const tile = tiles[y]?.[x];
    if (!tile) {
      return false;
    }
    
    // Cannot place on water
    if (tile.terrain === 'water') {
      return false;
    }
    
    // Cannot place on existing zone
    if (tile.zone !== null) {
      return false;
    }
    
    // Medium density must be unlocked
    if (density === 'medium' && !unlockedFeatures.mediumDensity) {
      return false;
    }
    
    // Check budget based on density
    const cost = density === 'medium' ? ZONE_COST_MEDIUM : ZONE_COST;
    if (budget < cost) {
      return false;
    }
    
    return true;
  },
  
  placeZone: (x: number, y: number, zoneType: ZoneType, density: ZoneDensity = 'low') => {
    const { canPlaceZone, tiles, budget } = get();
    
    // Validate placement
    if (!canPlaceZone(x, y, density)) {
      return false;
    }
    
    // Determine cost based on density
    const cost = density === 'medium' ? ZONE_COST_MEDIUM : ZONE_COST;
    
    // Create new tiles array with the zone placed
    const newTiles = tiles.map((row, rowY) =>
      row.map((tile, colX) => {
        if (colX === x && rowY === y) {
          return { ...tile, zone: zoneType, zoneDensity: density };
        }
        return tile;
      })
    );
    
    // Update state
    set({
      tiles: newTiles,
      budget: budget - cost,
    });
    
    return true;
  },
  
  canPlaceRoad: (x: number, y: number) => {
    const { tiles, budget } = get();
    
    // Check bounds
    if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) {
      return false;
    }
    
    const tile = tiles[y]?.[x];
    if (!tile) {
      return false;
    }
    
    // Cannot place on water
    if (tile.terrain === 'water') {
      return false;
    }
    
    // Cannot place if road already exists
    if (tile.hasRoad) {
      return false;
    }
    
    // Cannot place on existing zone
    if (tile.zone !== null) {
      return false;
    }
    
    // Check budget
    if (budget < ROAD_COST) {
      return false;
    }
    
    return true;
  },
  
  placeRoad: (x: number, y: number) => {
    const { canPlaceRoad, tiles, budget } = get();
    
    // Validate placement
    if (!canPlaceRoad(x, y)) {
      return false;
    }
    
    // Create new tiles array with the road placed
    const newTiles = tiles.map((row, rowY) =>
      row.map((tile, colX) => {
        if (colX === x && rowY === y) {
          return { ...tile, hasRoad: true };
        }
        return tile;
      })
    );
    
    // Update state
    set({
      tiles: newTiles,
      budget: budget - ROAD_COST,
    });
    
    return true;
  },
  
  hasRoadAccess: (x: number, y: number) => {
    const { tiles } = get();
    
    // Check bounds
    if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) {
      return false;
    }
    
    // Check adjacent tiles (N/S/E/W) for roads
    const adjacentCoords = [
      { x: x, y: y - 1 },     // North
      { x: x, y: y + 1 },     // South
      { x: x - 1, y: y },     // West
      { x: x + 1, y: y },     // East
    ];
    
    for (const coord of adjacentCoords) {
      // Check bounds for adjacent tile
      if (coord.x >= 0 && coord.x < MAP_SIZE && coord.y >= 0 && coord.y < MAP_SIZE) {
        const adjacentTile = tiles[coord.y]?.[coord.x];
        if (adjacentTile?.hasRoad) {
          return true;
        }
      }
    }
    
    return false;
  },
  
  canPlacePowerPlant: (x: number, y: number) => {
    const { tiles, budget, powerPlants } = get();
    
    // Check bounds
    if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) {
      return false;
    }
    
    const tile = tiles[y]?.[x];
    if (!tile) {
      return false;
    }
    
    // Cannot place on water
    if (tile.terrain === 'water') {
      return false;
    }
    
    // Cannot place on existing zone
    if (tile.zone !== null) {
      return false;
    }
    
    // Cannot place on existing power plant
    if (powerPlants.some(pp => pp.x === x && pp.y === y)) {
      return false;
    }
    
    // Check budget
    if (budget < POWER_PLANT_COST) {
      return false;
    }
    
    return true;
  },
  
  placePowerPlant: (x: number, y: number) => {
    const { canPlacePowerPlant, budget, powerPlants } = get();
    
    // Validate placement
    if (!canPlacePowerPlant(x, y)) {
      return false;
    }
    
    // Create new power plant
    const newPowerPlant: PowerPlant = {
      x,
      y,
      capacity: POWER_PLANT_CAPACITY,
      output: 0, // Will be calculated based on demand
    };
    
    // Update state
    set({
      powerPlants: [...powerPlants, newPowerPlant],
      budget: budget - POWER_PLANT_COST,
    });
    
    // Recalculate power grid
    get().calculatePowerGrid();
    
    return true;
  },
  
  canPlacePowerLine: (x: number, y: number) => {
    const { tiles, budget } = get();
    
    // Check bounds
    if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) {
      return false;
    }
    
    const tile = tiles[y]?.[x];
    if (!tile) {
      return false;
    }
    
    // Cannot place on water
    if (tile.terrain === 'water') {
      return false;
    }
    
    // Cannot place if power line already exists
    if (tile.hasPowerLine) {
      return false;
    }
    
    // Check budget
    if (budget < POWER_LINE_COST) {
      return false;
    }
    
    // Power lines CAN be placed on zones and roads
    return true;
  },
  
  placePowerLine: (x: number, y: number) => {
    const { canPlacePowerLine, tiles, budget } = get();
    
    // Validate placement
    if (!canPlacePowerLine(x, y)) {
      return false;
    }
    
    // Create new tiles array with the power line placed
    const newTiles = tiles.map((row, rowY) =>
      row.map((tile, colX) => {
        if (colX === x && rowY === y) {
          return { ...tile, hasPowerLine: true };
        }
        return tile;
      })
    );
    
    // Update state
    set({
      tiles: newTiles,
      budget: budget - POWER_LINE_COST,
    });
    
    // Recalculate power grid
    get().calculatePowerGrid();
    
    return true;
  },
  
  getPowerPlantAt: (x: number, y: number) => {
    const { powerPlants } = get();
    return powerPlants.find(pp => pp.x === x && pp.y === y) ?? null;
  },
  
  hasPower: (x: number, y: number) => {
    const { tiles } = get();
    
    // Check bounds
    if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) {
      return false;
    }
    
    const tile = tiles[y]?.[x];
    return tile?.isPowered ?? false;
  },
  
  calculatePowerGrid: () => {
    const { tiles, powerPlants } = get();
    
    if (tiles.length === 0) return;
    
    // Reset all power states
    const newTiles = tiles.map(row =>
      row.map(tile => ({ ...tile, isPowered: false }))
    );
    
    // BFS from each power plant to find powered tiles
    const visited = new Set<string>();
    const powerLineQueue: Array<{ x: number; y: number }> = [];
    
    // Start with power plants - they power themselves and adjacent tiles
    for (const plant of powerPlants) {
      const key = `${plant.x},${plant.y}`;
      if (!visited.has(key)) {
        visited.add(key);
        // Power plant tile is powered
        const plantTile = newTiles[plant.y]?.[plant.x];
        if (plantTile) {
          plantTile.isPowered = true;
        }
        // Add power plant location to start power line propagation
        powerLineQueue.push({ x: plant.x, y: plant.y });
      }
    }
    
    // BFS through power lines - power travels infinitely through power lines
    while (powerLineQueue.length > 0) {
      const current = powerLineQueue.shift()!;
      
      // Check adjacent tiles for power lines
      const adjacentCoords = [
        { x: current.x, y: current.y - 1 },     // North
        { x: current.x, y: current.y + 1 },     // South
        { x: current.x - 1, y: current.y },     // West
        { x: current.x + 1, y: current.y },     // East
      ];
      
      for (const coord of adjacentCoords) {
        const key = `${coord.x},${coord.y}`;
        if (visited.has(key)) continue;
        
        // Check bounds
        if (coord.x < 0 || coord.x >= MAP_SIZE || coord.y < 0 || coord.y >= MAP_SIZE) {
          continue;
        }
        
        const tile = newTiles[coord.y]?.[coord.x];
        if (!tile) continue;
        
        // If this tile has a power line, propagate through it
        if (tile.hasPowerLine) {
          visited.add(key);
          tile.isPowered = true;
          powerLineQueue.push(coord);
        }
      }
    }
    
    // Now propagate power to tiles within POWER_RANGE of any powered tile (power plants or power lines)
    const poweredTiles: Array<{ x: number; y: number }> = [];
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tile = newTiles[y]?.[x];
        if (tile && tile.isPowered) {
          poweredTiles.push({ x, y });
        }
      }
    }
    
    // Also add power plant positions
    for (const plant of powerPlants) {
      poweredTiles.push({ x: plant.x, y: plant.y });
    }
    
    // For each tile on the map, check if it's within range of any powered source
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tile = newTiles[y]?.[x];
        if (!tile || tile.isPowered) continue;
        
        // Check distance to any powered tile
        for (const powered of poweredTiles) {
          const distance = Math.abs(x - powered.x) + Math.abs(y - powered.y); // Manhattan distance
          if (distance <= POWER_RANGE) {
            tile.isPowered = true;
            break;
          }
        }
      }
    }
    
    // Update state
    set({ tiles: newTiles });
  },
  
  canPlaceWaterPump: (x: number, y: number) => {
    const { tiles, budget, waterPumps, powerPlants } = get();
    
    // Check bounds
    if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) {
      return false;
    }
    
    const tile = tiles[y]?.[x];
    if (!tile) {
      return false;
    }
    
    // Cannot place on water terrain
    if (tile.terrain === 'water') {
      return false;
    }
    
    // Cannot place on existing zone
    if (tile.zone !== null) {
      return false;
    }
    
    // Cannot place on existing water pump
    if (waterPumps.some(wp => wp.x === x && wp.y === y)) {
      return false;
    }
    
    // Cannot place on existing power plant
    if (powerPlants.some(pp => pp.x === x && pp.y === y)) {
      return false;
    }
    
    // Check budget
    if (budget < WATER_PUMP_COST) {
      return false;
    }
    
    return true;
  },
  
  placeWaterPump: (x: number, y: number) => {
    const { canPlaceWaterPump, budget, waterPumps } = get();
    
    // Validate placement
    if (!canPlaceWaterPump(x, y)) {
      return false;
    }
    
    // Create new water pump
    const newWaterPump: WaterPump = {
      x,
      y,
      capacity: WATER_PUMP_CAPACITY,
    };
    
    // Update state
    set({
      waterPumps: [...waterPumps, newWaterPump],
      budget: budget - WATER_PUMP_COST,
    });
    
    // Recalculate water grid
    get().calculateWaterGrid();
    
    return true;
  },
  
  canPlaceWaterPipe: (x: number, y: number) => {
    const { tiles, budget } = get();
    
    // Check bounds
    if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) {
      return false;
    }
    
    const tile = tiles[y]?.[x];
    if (!tile) {
      return false;
    }
    
    // Cannot place on water terrain
    if (tile.terrain === 'water') {
      return false;
    }
    
    // Cannot place if water pipe already exists
    if (tile.hasWaterPipe) {
      return false;
    }
    
    // Check budget
    if (budget < WATER_PIPE_COST) {
      return false;
    }
    
    // Water pipes CAN be placed on zones and roads
    return true;
  },
  
  placeWaterPipe: (x: number, y: number) => {
    const { canPlaceWaterPipe, tiles, budget } = get();
    
    // Validate placement
    if (!canPlaceWaterPipe(x, y)) {
      return false;
    }
    
    // Create new tiles array with the water pipe placed
    const newTiles = tiles.map((row, rowY) =>
      row.map((tile, colX) => {
        if (colX === x && rowY === y) {
          return { ...tile, hasWaterPipe: true };
        }
        return tile;
      })
    );
    
    // Update state
    set({
      tiles: newTiles,
      budget: budget - WATER_PIPE_COST,
    });
    
    // Recalculate water grid
    get().calculateWaterGrid();
    
    return true;
  },
  
  getWaterPumpAt: (x: number, y: number) => {
    const { waterPumps } = get();
    return waterPumps.find(wp => wp.x === x && wp.y === y) ?? null;
  },
  
  hasWater: (x: number, y: number) => {
    const { tiles } = get();
    
    // Check bounds
    if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) {
      return false;
    }
    
    const tile = tiles[y]?.[x];
    return tile?.hasWaterService ?? false;
  },
  
  calculateWaterGrid: () => {
    const { tiles, waterPumps } = get();
    
    if (tiles.length === 0) return;
    
    // Reset all water service states
    const newTiles = tiles.map(row =>
      row.map(tile => ({ ...tile, hasWaterService: false }))
    );
    
    // BFS from each water pump to find serviced tiles
    const visited = new Set<string>();
    const waterPipeQueue: Array<{ x: number; y: number }> = [];
    
    // Start with water pumps - they service themselves and adjacent tiles
    for (const pump of waterPumps) {
      const key = `${pump.x},${pump.y}`;
      if (!visited.has(key)) {
        visited.add(key);
        // Water pump tile is serviced
        const pumpTile = newTiles[pump.y]?.[pump.x];
        if (pumpTile) {
          pumpTile.hasWaterService = true;
        }
        // Add water pump location to start water pipe propagation
        waterPipeQueue.push({ x: pump.x, y: pump.y });
      }
    }
    
    // BFS through water pipes - water travels infinitely through pipes
    while (waterPipeQueue.length > 0) {
      const current = waterPipeQueue.shift()!;
      
      // Check adjacent tiles for water pipes
      const adjacentCoords = [
        { x: current.x, y: current.y - 1 },     // North
        { x: current.x, y: current.y + 1 },     // South
        { x: current.x - 1, y: current.y },     // West
        { x: current.x + 1, y: current.y },     // East
      ];
      
      for (const coord of adjacentCoords) {
        const key = `${coord.x},${coord.y}`;
        if (visited.has(key)) continue;
        
        // Check bounds
        if (coord.x < 0 || coord.x >= MAP_SIZE || coord.y < 0 || coord.y >= MAP_SIZE) {
          continue;
        }
        
        const tile = newTiles[coord.y]?.[coord.x];
        if (!tile) continue;
        
        // If this tile has a water pipe, propagate through it
        if (tile.hasWaterPipe) {
          visited.add(key);
          tile.hasWaterService = true;
          waterPipeQueue.push(coord);
        }
      }
    }
    
    // Now propagate water service to tiles within WATER_RANGE of any serviced tile (water pumps or water pipes)
    const servicedTiles: Array<{ x: number; y: number }> = [];
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tile = newTiles[y]?.[x];
        if (tile && tile.hasWaterService) {
          servicedTiles.push({ x, y });
        }
      }
    }
    
    // Also add water pump positions
    for (const pump of waterPumps) {
      servicedTiles.push({ x: pump.x, y: pump.y });
    }
    
    // For each tile on the map, check if it's within range of any water source
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tile = newTiles[y]?.[x];
        if (!tile || tile.hasWaterService) continue;
        
        // Check distance to any serviced tile
        for (const serviced of servicedTiles) {
          const distance = Math.abs(x - serviced.x) + Math.abs(y - serviced.y); // Manhattan distance
          if (distance <= WATER_RANGE) {
            tile.hasWaterService = true;
            break;
          }
        }
      }
    }
    
    // Update state
    set({ tiles: newTiles });
  },
  
  advanceMonth: () => {
    const { gameMonth, gameYear } = get();
    
    if (gameMonth >= 12) {
      // Roll over to next year
      set({ gameMonth: 1, gameYear: gameYear + 1 });
    } else {
      set({ gameMonth: gameMonth + 1 });
    }
  },
  
  runMonthlySimulation: () => {
    const { tiles, advanceMonth, demand, calculateDemand, calculateCrime, calculatePollution, getCrimeAt, getPollutionAt } = get();
    
    if (tiles.length === 0) return;
    
    // Create new tiles array for immutability
    const newTiles = tiles.map(row => row.map(tile => ({ ...tile })));
    let totalPopulation = 0;
    let totalCommercialJobs = 0;
    let totalIndustrialJobs = 0;
    
    // Track abandonment events for notifications
    const abandonmentEvents: AbandonmentEvent[] = [];
    
    // Process each tile for zone development and abandonment
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tile = newTiles[y]?.[x];
        if (!tile || !tile.zone) continue;
        
        // Check if zone has ALL required utilities (road + power + water)
        const hasRoadAccess = get().hasRoadAccess(tile.x, tile.y);
        const hasPower = tile.isPowered;
        const hasWater = tile.hasWaterService;
        const hasAllUtilities = hasRoadAccess && hasPower && hasWater;
        
        // Get crime level for this tile (affects development speed and abandonment)
        const crimeLevel = getCrimeAt(tile.x, tile.y);
        // High crime (>50) slows development: 50% at crime=100, 100% at crime=0
        const crimeMultiplier = 1 - (crimeLevel / 200); // 0.5 to 1.0
        
        // Get pollution level for this tile (affects ONLY residential development and abandonment)
        const pollutionLevel = getPollutionAt(tile.x, tile.y);
        // Pollution slows residential development: 50% at pollution=100, 100% at pollution=0
        const pollutionMultiplier = tile.zone === 'residential' 
          ? 1 - (pollutionLevel * POLLUTION_DEVELOPMENT_PENALTY) // 0.5 to 1.0
          : 1.0; // No effect on commercial/industrial
        
        // === ABANDONMENT LOGIC for developed buildings ===
        const isDeveloped = tile.developmentProgress >= 100;
        
        if (isDeveloped && !tile.isAbandoned) {
          // Track months without power
          if (!hasPower) {
            tile.monthsWithoutPower = (tile.monthsWithoutPower || 0) + 1;
          } else {
            tile.monthsWithoutPower = 0;
          }
          
          // Track months without water
          if (!hasWater) {
            tile.monthsWithoutWater = (tile.monthsWithoutWater || 0) + 1;
          } else {
            tile.monthsWithoutWater = 0;
          }
          
          // Track months with high crime (>80)
          if (crimeLevel > ABANDONMENT_CRIME_THRESHOLD) {
            tile.monthsWithHighCrime = (tile.monthsWithHighCrime || 0) + 1;
          } else {
            tile.monthsWithHighCrime = 0;
          }
          
          // Track months with high pollution (>80) - residential only
          if (tile.zone === 'residential' && pollutionLevel > ABANDONMENT_POLLUTION_THRESHOLD) {
            tile.monthsWithHighPollution = (tile.monthsWithHighPollution || 0) + 1;
          } else {
            tile.monthsWithHighPollution = 0;
          }
          
          // Check abandonment conditions (in priority order)
          let abandonmentReason: 'no_power' | 'no_water' | 'high_crime' | 'high_pollution' | null = null;
          
          if ((tile.monthsWithoutPower || 0) >= ABANDONMENT_MONTHS_NO_POWER) {
            abandonmentReason = 'no_power';
          } else if ((tile.monthsWithoutWater || 0) >= ABANDONMENT_MONTHS_NO_WATER) {
            abandonmentReason = 'no_water';
          } else if ((tile.monthsWithHighCrime || 0) >= ABANDONMENT_MONTHS_HIGH_CRIME) {
            abandonmentReason = 'high_crime';
          } else if (tile.zone === 'residential' && (tile.monthsWithHighPollution || 0) >= ABANDONMENT_MONTHS_HIGH_POLLUTION) {
            abandonmentReason = 'high_pollution';
          }
          
          // Apply abandonment
          if (abandonmentReason) {
            tile.isAbandoned = true;
            tile.abandonmentReason = abandonmentReason;
            // Population/jobs will be zeroed when calculating totals
            
            // Record abandonment event for notification
            abandonmentEvents.push({
              x: tile.x,
              y: tile.y,
              zoneType: tile.zone as 'residential' | 'commercial' | 'industrial',
              reason: abandonmentReason,
            });
          }
        }
        
        // === DEVELOPMENT LOGIC for non-abandoned buildings ===
        if (hasAllUtilities && tile.developmentProgress < 100 && !tile.isAbandoned) {
          // Get demand multiplier based on zone type
          let demandValue = BASE_RESIDENTIAL_DEMAND;
          if (tile.zone === 'residential') {
            demandValue = demand.residential;
          } else if (tile.zone === 'commercial') {
            demandValue = demand.commercial;
          } else if (tile.zone === 'industrial') {
            demandValue = demand.industrial;
          }
          
          // Calculate demand multiplier
          let demandMultiplier = 1.0;
          if (demandValue > HIGH_DEMAND_THRESHOLD) {
            // High demand (>70): 50% faster development
            demandMultiplier = HIGH_DEMAND_MULTIPLIER;
          } else if (demandValue < LOW_DEMAND_THRESHOLD) {
            // Low demand (<30): 50% slower development
            demandMultiplier = LOW_DEMAND_MULTIPLIER;
          }
          
          // Zone can develop - base progress modified by demand, crime, and pollution (residential only)
          const baseProgress = BASE_DEVELOPMENT_PROGRESS + Math.floor(Math.random() * 11); // 10-20%
          const progressIncrease = Math.floor(baseProgress * demandMultiplier * crimeMultiplier * pollutionMultiplier);
          tile.developmentProgress = Math.min(100, tile.developmentProgress + progressIncrease);
          
          // When zone becomes fully developed, assign population/jobs
          if (tile.developmentProgress >= 100) {
            const isMediumDensity = tile.zoneDensity === 'medium';
            const landValueFactor = tile.landValue / 100; // 0 to 1
            
            if (tile.zone === 'residential') {
              // Residential: low density 10-50, medium density 20-100
              if (isMediumDensity) {
                tile.population = Math.floor(20 + landValueFactor * 80); // 20-100
              } else {
                tile.population = Math.floor(10 + landValueFactor * 40); // 10-50
              }
            } else if (tile.zone === 'commercial') {
              // Commercial: low density 5-25, medium density 10-50
              if (isMediumDensity) {
                tile.jobs = Math.floor(10 + landValueFactor * 40); // 10-50
              } else {
                tile.jobs = Math.floor(5 + landValueFactor * 20); // 5-25
              }
            } else if (tile.zone === 'industrial') {
              // Industrial: low density 10-40, medium density 20-80
              if (isMediumDensity) {
                tile.jobs = Math.floor(20 + landValueFactor * 60); // 20-80
              } else {
                tile.jobs = Math.floor(10 + landValueFactor * 30); // 10-40
              }
            }
          }
        }
        
        // Calculate totals from developed zones (only non-abandoned contribute)
        if (tile.developmentProgress >= 100 && !tile.isAbandoned) {
          if (tile.zone === 'residential') {
            totalPopulation += tile.population;
          } else if (tile.zone === 'commercial') {
            totalCommercialJobs += tile.jobs;
          } else if (tile.zone === 'industrial') {
            totalIndustrialJobs += tile.jobs;
          }
        }
      }
    }
    
    // Update state with new tiles, population, jobs, and abandonment events
    set({ 
      tiles: newTiles, 
      population: totalPopulation,
      commercialJobs: totalCommercialJobs,
      industrialJobs: totalIndustrialJobs,
      lastAbandonmentEvents: abandonmentEvents,
    });
    
    // Calculate demand based on new city state
    calculateDemand();
    
    // Calculate crime levels across the city
    calculateCrime();
    
    // Calculate pollution levels across the city
    calculatePollution();
    
    // Calculate monthly budget (revenue and expenses) - AFTER population is calculated
    get().calculateMonthlyBudget();
    
    // Advance to next month
    advanceMonth();
  },
  
  calculateDemand: () => {
    const { population, commercialJobs, industrialJobs } = get();
    
    // Total jobs for residential demand calculation
    const totalJobs = commercialJobs + industrialJobs;
    
    /**
     * Residential Demand Formula (from task spec):
     * - Base: 50
     * - +jobs/10 (people want to live near jobs)
     * - -population/20 (less demand when crowded)
     * - Clamp to 0-100
     */
    const residentialDemand = Math.max(0, Math.min(100,
      BASE_RESIDENTIAL_DEMAND + 
      Math.floor(totalJobs / 10) - 
      Math.floor(population / 20)
    ));
    
    /**
     * Commercial Demand Formula (from task spec):
     * - Base: 30
     * - +population/10 (shops need customers)
     * - -commercialJobs/5 (less demand when saturated)
     * - Clamp to 0-100
     */
    const commercialDemand = Math.max(0, Math.min(100,
      BASE_COMMERCIAL_DEMAND + 
      Math.floor(population / 10) - 
      Math.floor(commercialJobs / 5)
    ));
    
    /**
     * Industrial Demand Formula (from task spec):
     * - Base: 40
     * - +population/15 (industry serves population)
     * - -industrialJobs/5 (less demand when saturated)
     * - Clamp to 0-100
     */
    const industrialDemand = Math.max(0, Math.min(100,
      BASE_INDUSTRIAL_DEMAND + 
      Math.floor(population / 15) - 
      Math.floor(industrialJobs / 5)
    ));
    
    // Update demand state
    set({
      demand: {
        residential: residentialDemand,
        commercial: commercialDemand,
        industrial: industrialDemand,
      },
    });
  },
  
  checkMilestones: () => {
    const { population, milestonesReached, unlockedFeatures } = get();
    
    // Check if medium density should be unlocked
    if (population >= MEDIUM_DENSITY_UNLOCK_POPULATION && !unlockedFeatures.mediumDensity) {
      set({
        unlockedFeatures: {
          ...unlockedFeatures,
          mediumDensity: true,
        },
      });
    }
    
    // Find the first milestone that has been crossed but not yet recorded
    for (const milestone of MILESTONES) {
      if (population >= milestone && !milestonesReached.includes(milestone)) {
        // Add this milestone to the reached list
        set({
          milestonesReached: [...milestonesReached, milestone],
        });
        // Return the newly reached milestone
        return milestone;
      }
    }
    
    // No new milestone reached
    return null;
  },
  
  calculateMonthlyBudget: () => {
    const { tiles, population, powerPlants, waterPumps, policeStations, budget, isInDeficit } = get();
    
    // Calculate tax revenue from population
    const taxRevenue = population * TAX_RATE_PER_PERSON;
    
    // Count road tiles for maintenance calculation
    let roadTileCount = 0;
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tile = tiles[y]?.[x];
        if (tile?.hasRoad) {
          roadTileCount++;
        }
      }
    }
    
    // Calculate maintenance costs
    const roadMaintenance = roadTileCount * ROAD_MAINTENANCE_COST;
    const powerMaintenance = powerPlants.length * POWER_PLANT_MAINTENANCE_COST;
    const waterMaintenance = waterPumps.length * WATER_PUMP_MAINTENANCE_COST;
    const policeMaintenance = policeStations.length * POLICE_STATION_MAINTENANCE_COST;
    
    // Total expenses
    const totalExpenses = roadMaintenance + powerMaintenance + waterMaintenance + policeMaintenance;
    
    // Net change
    const netChange = taxRevenue - totalExpenses;
    
    // Update budget and tracking
    const newBudget = budget + netChange;
    
    // Determine deficit event
    const wasInDeficit = isInDeficit;
    const nowInDeficit = newBudget < 0;
    let deficitEvent: BudgetDeficitEvent = null;
    
    if (nowInDeficit && !wasInDeficit) {
      // Just entered deficit
      deficitEvent = 'entered_deficit';
    } else if (nowInDeficit && wasInDeficit) {
      // Still in deficit (monthly reminder)
      deficitEvent = 'still_in_deficit';
    }
    
    set({
      budget: newBudget,
      monthlyRevenue: taxRevenue,
      monthlyExpenses: totalExpenses,
      lastBudgetChange: netChange,
      budgetBreakdown: {
        taxRevenue,
        roadMaintenance,
        powerMaintenance,
        waterMaintenance,
        policeMaintenance,
        totalExpenses,
        netChange,
      },
      isInDeficit: nowInDeficit,
      lastDeficitEvent: deficitEvent,
    });
  },
  
  checkBudgetDeficitEvent: () => {
    const { lastDeficitEvent } = get();
    // Clear the event after reading it
    if (lastDeficitEvent !== null) {
      set({ lastDeficitEvent: null });
    }
    return lastDeficitEvent;
  },
  
  getSaveData: () => {
    const state = get();
    return {
      tiles: state.tiles,
      powerPlants: state.powerPlants,
      waterPumps: state.waterPumps,
      policeStations: state.policeStations,
      budget: state.budget,
      population: state.population,
      commercialJobs: state.commercialJobs,
      industrialJobs: state.industrialJobs,
      gameYear: state.gameYear,
      gameMonth: state.gameMonth,
      demand: state.demand,
      milestonesReached: state.milestonesReached,
      unlockedFeatures: state.unlockedFeatures,
    };
  },
  
  loadSaveData: (saveData: SaveableGameState) => {
    set({
      tiles: saveData.tiles,
      powerPlants: saveData.powerPlants,
      waterPumps: saveData.waterPumps,
      policeStations: saveData.policeStations || [], // Handle older saves without police stations
      crimeMap: new Map(), // Will be recalculated
      pollutionMap: new Map(), // Will be recalculated
      budget: saveData.budget,
      population: saveData.population,
      commercialJobs: saveData.commercialJobs,
      industrialJobs: saveData.industrialJobs,
      gameYear: saveData.gameYear,
      gameMonth: saveData.gameMonth,
      demand: saveData.demand,
      milestonesReached: saveData.milestonesReached,
      unlockedFeatures: saveData.unlockedFeatures,
      isInitialized: true,
      // Reset budget tracking to recalculate from loaded state
      monthlyRevenue: 0,
      monthlyExpenses: 0,
      lastBudgetChange: 0,
      budgetBreakdown: {
        taxRevenue: 0,
        roadMaintenance: 0,
        powerMaintenance: 0,
        waterMaintenance: 0,
        policeMaintenance: 0,
        totalExpenses: 0,
        netChange: 0,
      },
      isInDeficit: saveData.budget < 0,
      lastDeficitEvent: null,
    });
    // Recalculate crime and pollution after loading
    get().calculateCrime();
    get().calculatePollution();
  },
  
  canBulldoze: (x: number, y: number) => {
    const { tiles, budget, powerPlants, waterPumps, policeStations } = get();
    
    // Check bounds
    if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) {
      return false;
    }
    
    const tile = tiles[y]?.[x];
    if (!tile) {
      return false;
    }
    
    // Check budget
    if (budget < BULLDOZE_COST) {
      return false;
    }
    
    // Check if there's anything to bulldoze
    const hasPowerPlant = powerPlants.some(pp => pp.x === x && pp.y === y);
    const hasWaterPump = waterPumps.some(wp => wp.x === x && wp.y === y);
    const hasPoliceStation = policeStations.some(ps => ps.position.gridX === x && ps.position.gridY === y);
    const hasStructure = tile.zone !== null || 
                         tile.hasRoad || 
                         tile.hasPowerLine || 
                         tile.hasWaterPipe ||
                         hasPowerPlant ||
                         hasWaterPump ||
                         hasPoliceStation;
    
    return hasStructure;
  },
  
  bulldoze: (x: number, y: number) => {
    const { canBulldoze, tiles, budget, powerPlants, waterPumps, policeStations, population, commercialJobs, industrialJobs } = get();
    
    // Validate bulldoze action
    if (!canBulldoze(x, y)) {
      return false;
    }
    
    const tile = tiles[y]?.[x];
    if (!tile) {
      return false;
    }
    
    // Track what was removed for utility recalculation
    const hadPowerLine = tile.hasPowerLine;
    const hadWaterPipe = tile.hasWaterPipe;
    const wasPowerPlant = powerPlants.some(pp => pp.x === x && pp.y === y);
    const wasWaterPump = waterPumps.some(wp => wp.x === x && wp.y === y);
    const wasPoliceStation = policeStations.some(ps => ps.position.gridX === x && ps.position.gridY === y);
    
    // Track population/job changes if residential/commercial/industrial was removed
    let populationDecrease = 0;
    let commercialJobsDecrease = 0;
    let industrialJobsDecrease = 0;
    
    if (tile.zone === 'residential' && tile.developmentProgress >= 100) {
      populationDecrease = tile.population;
    } else if (tile.zone === 'commercial' && tile.developmentProgress >= 100) {
      commercialJobsDecrease = tile.jobs;
    } else if (tile.zone === 'industrial' && tile.developmentProgress >= 100) {
      industrialJobsDecrease = tile.jobs;
    }
    
    // Create new tiles array with the bulldozed tile
    const newTiles = tiles.map((row, rowY) =>
      row.map((t, colX) => {
        if (colX === x && rowY === y) {
          // Create a new tile without zoneDensity property
          const { zoneDensity: _, ...rest } = t;
          return {
            ...rest,
            zone: null,
            hasRoad: false,
            hasPowerLine: false,
            hasWaterPipe: false,
            developmentProgress: 0,
            population: 0,
            jobs: 0,
          };
        }
        return t;
      })
    );
    
    // Remove power plant if present
    const newPowerPlants = powerPlants.filter(pp => !(pp.x === x && pp.y === y));
    
    // Remove water pump if present
    const newWaterPumps = waterPumps.filter(wp => !(wp.x === x && wp.y === y));
    
    // Remove police station if present
    const newPoliceStations = policeStations.filter(ps => !(ps.position.gridX === x && ps.position.gridY === y));
    
    // Update state
    set({
      tiles: newTiles,
      budget: budget - BULLDOZE_COST,
      powerPlants: newPowerPlants,
      waterPumps: newWaterPumps,
      policeStations: newPoliceStations,
      population: population - populationDecrease,
      commercialJobs: commercialJobs - commercialJobsDecrease,
      industrialJobs: industrialJobs - industrialJobsDecrease,
    });
    
    // Recalculate utility grids if infrastructure was removed
    if (hadPowerLine || wasPowerPlant) {
      get().calculatePowerGrid();
    }
    if (hadWaterPipe || wasWaterPump) {
      get().calculateWaterGrid();
    }
    
    // Recalculate crime if police station was removed
    if (wasPoliceStation) {
      get().calculateCrime();
    }
    
    // Recalculate demand if population or jobs changed
    if (populationDecrease > 0 || commercialJobsDecrease > 0 || industrialJobsDecrease > 0) {
      get().calculateDemand();
    }
    
    return true;
  },
  
  checkForDisaster: () => {
    const { population, tiles } = get();
    
    // Check if a random disaster should occur
    const disasterType = disasterSystem.checkForRandomDisaster(population);
    
    if (disasterType) {
      // Start the disaster
      const disaster = disasterSystem.startDisaster(disasterType, tiles);
      
      if (disaster) {
        // Update active disasters in state
        set({
          activeDisasters: disasterSystem.getActiveDisasters(),
          disasterAffectedTiles: disasterSystem.getAffectedTiles(),
        });
        
        return disasterType;
      }
    }
    
    return null;
  },
  
  updateDisasters: () => {
    const { tiles, powerPlants, waterPumps, population, commercialJobs, industrialJobs } = get();
    
    // Skip if no active disasters
    if (!disasterSystem.hasActiveDisasters()) {
      return;
    }
    
    // Update disasters and get damage
    const damage = disasterSystem.update(tiles, powerPlants, waterPumps);
    
    // Apply damage to tiles
    if (damage.damagedTiles.length > 0 || damage.destroyedPowerPlants.length > 0 || damage.destroyedWaterPumps.length > 0) {
      const newTiles = tiles.map(row => row.map(tile => ({ ...tile })));
      
      // Damage/destroy affected tiles
      for (const { x, y } of damage.damagedTiles) {
        const tile = newTiles[y]?.[x];
        if (tile) {
          // Remove zone and reset development
          const { zoneDensity: _, ...rest } = tile;
          Object.assign(tile, {
            ...rest,
            zone: null,
            developmentProgress: 0,
            population: 0,
            jobs: 0,
            // Also remove infrastructure on destroyed tiles
            hasRoad: false,
            hasPowerLine: false,
            hasWaterPipe: false,
          });
        }
      }
      
      // Remove destroyed power plants
      const newPowerPlants = powerPlants.filter(
        pp => !damage.destroyedPowerPlants.some(d => d.x === pp.x && d.y === pp.y)
      );
      
      // Remove destroyed water pumps
      const newWaterPumps = waterPumps.filter(
        wp => !damage.destroyedWaterPumps.some(d => d.x === wp.x && d.y === wp.y)
      );
      
      // Calculate total damage for event
      const totalInfrastructureDestroyed = 
        damage.destroyedPowerPlants.length + damage.destroyedWaterPumps.length;
      
      // Update state
      set({
        tiles: newTiles,
        powerPlants: newPowerPlants,
        waterPumps: newWaterPumps,
        population: Math.max(0, population - damage.populationLost),
        commercialJobs: Math.max(0, commercialJobs - (damage.jobsLost > 0 ? Math.floor(damage.jobsLost / 2) : 0)),
        industrialJobs: Math.max(0, industrialJobs - (damage.jobsLost > 0 ? Math.ceil(damage.jobsLost / 2) : 0)),
        activeDisasters: disasterSystem.getActiveDisasters(),
        disasterAffectedTiles: disasterSystem.getAffectedTiles(),
        lastDisasterEvent: damage.damagedTiles.length > 0 || totalInfrastructureDestroyed > 0 ? {
          type: disasterSystem.getActiveDisasters()[0]?.type || 'fire',
          damage: {
            tilesDestroyed: damage.damagedTiles.length,
            populationLost: damage.populationLost,
            jobsLost: damage.jobsLost,
            infrastructureDestroyed: totalInfrastructureDestroyed,
          },
        } : null,
      });
      
      // Recalculate grids if infrastructure was destroyed
      if (newPowerPlants.length !== powerPlants.length) {
        get().calculatePowerGrid();
      }
      if (newWaterPumps.length !== waterPumps.length) {
        get().calculateWaterGrid();
      }
    } else {
      // Just update affected tiles for rendering
      set({
        activeDisasters: disasterSystem.getActiveDisasters(),
        disasterAffectedTiles: disasterSystem.getAffectedTiles(),
      });
    }
  },
  
  getLastDisasterEvent: () => {
    const { lastDisasterEvent } = get();
    if (lastDisasterEvent) {
      set({ lastDisasterEvent: null });
    }
    return lastDisasterEvent;
  },
  
  getDisasterAffectedTiles: () => {
    return disasterSystem.getAffectedTiles();
  },
  
  hasActiveDisasters: () => {
    return disasterSystem.hasActiveDisasters();
  },

  /**
   * Manually trigger a disaster (for testing/debugging)
   * Can be called from browser console: useGameStore.getState().triggerDisaster('fire')
   */
  triggerDisaster: (type: DisasterType) => {
    const { tiles } = get();
    
    const disaster = disasterSystem.startDisaster(type, tiles);
    
    if (disaster) {
      set({
        activeDisasters: disasterSystem.getActiveDisasters(),
        disasterAffectedTiles: disasterSystem.getAffectedTiles(),
      });
      
      // Return true to indicate disaster started
      return true;
    }
    
    return false;
  },
  
  canPlacePoliceStation: (x: number, y: number) => {
    const { tiles, budget, powerPlants, waterPumps, policeStations } = get();
    
    // Check bounds
    if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) {
      return false;
    }
    
    const tile = tiles[y]?.[x];
    if (!tile) {
      return false;
    }
    
    // Cannot place on water terrain
    if (tile.terrain === 'water') {
      return false;
    }
    
    // Cannot place on existing zone
    if (tile.zone !== null) {
      return false;
    }
    
    // Cannot place on existing police station
    if (policeStations.some(ps => ps.position.gridX === x && ps.position.gridY === y)) {
      return false;
    }
    
    // Cannot place on existing power plant
    if (powerPlants.some(pp => pp.x === x && pp.y === y)) {
      return false;
    }
    
    // Cannot place on existing water pump
    if (waterPumps.some(wp => wp.x === x && wp.y === y)) {
      return false;
    }
    
    // Check budget
    if (budget < POLICE_STATION_COST) {
      return false;
    }
    
    return true;
  },
  
  placePoliceStation: (x: number, y: number) => {
    const { canPlacePoliceStation, budget, policeStations } = get();
    
    // Validate placement
    if (!canPlacePoliceStation(x, y)) {
      return false;
    }
    
    // Create new police station with unique ID
    const newPoliceStation: PoliceStation = {
      id: `police_${x}_${y}_${Date.now()}`,
      position: { gridX: x, gridY: y },
    };
    
    // Update state
    set({
      policeStations: [...policeStations, newPoliceStation],
      budget: budget - POLICE_STATION_COST,
    });
    
    // Recalculate crime grid
    get().calculateCrime();
    
    return true;
  },
  
  getPoliceStationAt: (x: number, y: number) => {
    const { policeStations } = get();
    return policeStations.find(ps => ps.position.gridX === x && ps.position.gridY === y) ?? null;
  },
  
  calculateCrime: () => {
    const { tiles, policeStations } = get();
    
    if (tiles.length === 0) return;
    
    const newCrimeMap = new Map<string, number>();
    
    // Calculate crime for each tile
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tile = tiles[y]?.[x];
        if (!tile) continue;
        
        // Skip water tiles
        if (tile.terrain === 'water') continue;
        
        // Base crime starts at 0
        let baseCrime = 0;
        
        // Crime is generated by population density
        if (tile.zone && tile.developmentProgress >= 100) {
          // Residential zones generate crime based on population
          if (tile.zone === 'residential') {
            baseCrime = Math.min(100, tile.population * 0.5); // 0.5 crime per person
          }
          // Industrial zones generate 50% more crime
          else if (tile.zone === 'industrial') {
            baseCrime = Math.min(100, tile.jobs * 1.5); // 1.5 crime per job
          }
          // Commercial zones have moderate crime
          else if (tile.zone === 'commercial') {
            baseCrime = Math.min(100, tile.jobs * 0.8); // 0.8 crime per job
          }
        }
        
        // Check for police coverage
        let hasPoliceProtection = false;
        for (const station of policeStations) {
          const distance = Math.abs(x - station.position.gridX) + Math.abs(y - station.position.gridY);
          if (distance <= POLICE_COVERAGE_RADIUS) {
            hasPoliceProtection = true;
            break;
          }
        }
        
        // Apply police reduction if covered
        let finalCrime = baseCrime;
        if (hasPoliceProtection) {
          finalCrime = baseCrime * (1 - POLICE_CRIME_REDUCTION);
        }
        
        // Clamp crime to 0-100
        finalCrime = Math.max(0, Math.min(100, finalCrime));
        
        // Store in map
        const tileKey = `${x},${y}`;
        newCrimeMap.set(tileKey, finalCrime);
      }
    }
    
    set({ crimeMap: newCrimeMap });
  },
  
  getCrimeAt: (x: number, y: number) => {
    const { crimeMap } = get();
    const tileKey = `${x},${y}`;
    return crimeMap.get(tileKey) ?? 0;
  },
  
  hasPoliceCoverage: (x: number, y: number) => {
    const { policeStations } = get();
    
    for (const station of policeStations) {
      const distance = Math.abs(x - station.position.gridX) + Math.abs(y - station.position.gridY);
      if (distance <= POLICE_COVERAGE_RADIUS) {
        return true;
      }
    }
    
    return false;
  },
  
  calculatePollution: () => {
    const { tiles } = get();
    
    if (tiles.length === 0) return;
    
    const newPollutionMap = new Map<string, number>();
    
    // First, find all industrial zones and their pollution output
    const industrialSources: Array<{ x: number; y: number; pollution: number }> = [];
    
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tile = tiles[y]?.[x];
        if (!tile) continue;
        
        // Only developed industrial zones generate pollution
        if (tile.zone === 'industrial' && tile.developmentProgress >= 100) {
          // Pollution based on jobs: 50-100 pollution (more jobs = more pollution)
          // Industrial low density: 10-40 jobs, medium: 20-80 jobs
          const maxJobs = tile.zoneDensity === 'medium' ? INDUSTRIAL_JOBS_MEDIUM : INDUSTRIAL_JOBS_LOW;
          const jobRatio = tile.jobs / maxJobs;
          const basePollution = BASE_INDUSTRIAL_POLLUTION + (jobRatio * 50); // 50-100
          
          industrialSources.push({ x, y, pollution: basePollution });
        }
      }
    }
    
    // Now calculate pollution for each tile based on nearby industrial sources
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tile = tiles[y]?.[x];
        if (!tile) continue;
        
        // Skip water tiles
        if (tile.terrain === 'water') continue;
        
        let totalPollution = 0;
        
        // Sum up pollution from all nearby industrial sources
        for (const source of industrialSources) {
          const distance = Math.abs(x - source.x) + Math.abs(y - source.y); // Manhattan distance
          
          if (distance <= POLLUTION_SPREAD_RADIUS) {
            // Linear falloff: 100% at source, 0% at edge of radius
            const falloff = 1 - (distance / POLLUTION_SPREAD_RADIUS);
            const contributedPollution = source.pollution * falloff;
            totalPollution += contributedPollution;
          }
        }
        
        // Clamp pollution to MAX_POLLUTION (100)
        const finalPollution = Math.min(MAX_POLLUTION, Math.max(0, totalPollution));
        
        // Store in map
        const tileKey = `${x},${y}`;
        newPollutionMap.set(tileKey, finalPollution);
      }
    }
    
    set({ pollutionMap: newPollutionMap });
  },
  
  getPollutionAt: (x: number, y: number) => {
    const { pollutionMap } = get();
    const tileKey = `${x},${y}`;
    return pollutionMap.get(tileKey) ?? 0;
  },
  
  getLastAbandonmentEvents: () => {
    const { lastAbandonmentEvents } = get();
    // Clear the events after reading them
    if (lastAbandonmentEvents.length > 0) {
      set({ lastAbandonmentEvents: [] });
    }
    return lastAbandonmentEvents;
  },
  
  generateRandomCity: () => {
    // First initialize the map with fresh terrain
    get().initializeMap();
    
    const { tiles } = get();
    const newTiles = tiles.map(row => row.map(tile => ({ ...tile })));
    const newPowerPlants: PowerPlant[] = [];
    const newWaterPumps: WaterPump[] = [];
    const newPoliceStations: PoliceStation[] = [];
    
    // Constants for city generation
    const ROAD_GRID_SPACING = 8; // Main roads every 8 tiles
    const ZONE_CHANCE = 0.7; // 70% chance to zone a tile adjacent to a road
    
    // Helper to check if a tile is buildable (grass, not water)
    const isBuildable = (x: number, y: number): boolean => {
      if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) return false;
      const tile = newTiles[y]?.[x];
      return tile?.terrain === 'grass';
    };
    
    // Helper to check if a tile is empty (no zone, road, or building)
    const isEmpty = (x: number, y: number): boolean => {
      if (!isBuildable(x, y)) return false;
      const tile = newTiles[y]?.[x];
      return !tile?.hasRoad && tile?.zone === null;
    };
    
    // Helper to check if a tile is adjacent to a road
    const isAdjacentToRoad = (x: number, y: number): boolean => {
      const adjacentCoords = [
        { ax: x, ay: y - 1 },
        { ax: x, ay: y + 1 },
        { ax: x - 1, ay: y },
        { ax: x + 1, ay: y },
      ];
      return adjacentCoords.some(({ ax, ay }) => {
        if (ax < 0 || ax >= MAP_SIZE || ay < 0 || ay >= MAP_SIZE) return false;
        return newTiles[ay]?.[ax]?.hasRoad === true;
      });
    };
    
    // Helper to find closest road tile from a position
    const findClosestRoadTile = (startX: number, startY: number): { x: number; y: number } | null => {
      // BFS to find nearest road
      const visited = new Set<string>();
      const queue: Array<{ x: number; y: number; dist: number }> = [{ x: startX, y: startY, dist: 0 }];
      
      while (queue.length > 0) {
        const current = queue.shift()!;
        const key = `${current.x},${current.y}`;
        
        if (visited.has(key)) continue;
        visited.add(key);
        
        if (current.x < 0 || current.x >= MAP_SIZE || current.y < 0 || current.y >= MAP_SIZE) continue;
        
        const tile = newTiles[current.y]?.[current.x];
        if (!tile || tile.terrain === 'water') continue;
        
        if (tile.hasRoad && current.dist > 0) {
          return { x: current.x, y: current.y };
        }
        
        // Search radius limit
        if (current.dist > 15) continue;
        
        // Add neighbors
        queue.push({ x: current.x + 1, y: current.y, dist: current.dist + 1 });
        queue.push({ x: current.x - 1, y: current.y, dist: current.dist + 1 });
        queue.push({ x: current.x, y: current.y + 1, dist: current.dist + 1 });
        queue.push({ x: current.x, y: current.y - 1, dist: current.dist + 1 });
      }
      
      return null;
    };
    
    // Helper to connect a point to the road network with utilities
    const connectToRoad = (startX: number, startY: number) => {
      const targetRoad = findClosestRoadTile(startX, startY);
      if (!targetRoad) return;
      
      // Draw a line of utilities from start to target road
      let x = startX;
      let y = startY;
      
      while (x !== targetRoad.x || y !== targetRoad.y) {
        const tile = newTiles[y]?.[x];
        if (tile && tile.terrain !== 'water') {
          tile.hasPowerLine = true;
          tile.hasWaterPipe = true;
        }
        
        // Move towards target
        if (x < targetRoad.x) x++;
        else if (x > targetRoad.x) x--;
        else if (y < targetRoad.y) y++;
        else if (y > targetRoad.y) y--;
      }
    };
    
    // 1. Create main road grid (horizontal and vertical roads)
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        // Create grid roads
        const isHorizontalRoad = y % ROAD_GRID_SPACING === ROAD_GRID_SPACING / 2;
        const isVerticalRoad = x % ROAD_GRID_SPACING === ROAD_GRID_SPACING / 2;
        
        if ((isHorizontalRoad || isVerticalRoad) && isBuildable(x, y)) {
          const tile = newTiles[y]?.[x];
          if (tile) {
            tile.hasRoad = true;
          }
        }
      }
    }
    
    // 2. Add some branching roads for variety
    const branchCount = 5 + Math.floor(Math.random() * 5); // 5-10 branches
    for (let i = 0; i < branchCount; i++) {
      const startX = Math.floor(Math.random() * MAP_SIZE);
      const startY = Math.floor(Math.random() * MAP_SIZE);
      const length = 5 + Math.floor(Math.random() * 10); // 5-15 tiles
      const horizontal = Math.random() > 0.5;
      
      for (let j = 0; j < length; j++) {
        const x = horizontal ? startX + j : startX;
        const y = horizontal ? startY : startY + j;
        
        if (isBuildable(x, y)) {
          const tile = newTiles[y]?.[x];
          if (tile && tile.zone === null) {
            tile.hasRoad = true;
          }
        }
      }
    }
    
    // 3. Place power/water lines on ALL road tiles (100% coverage for proper utility network)
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tile = newTiles[y]?.[x];
        if (tile?.hasRoad) {
          tile.hasPowerLine = true;
          tile.hasWaterPipe = true;
        }
      }
    }
    
    // 4. Place power plant(s) - 2-3 to ensure good coverage
    const powerPlantCount = 2 + Math.floor(Math.random() * 2); // 2-3 power plants
    for (let i = 0; i < powerPlantCount; i++) {
      let placed = false;
      // Try to place adjacent to roads first, then fall back to connecting
      for (let attempt = 0; attempt < 100 && !placed; attempt++) {
        const x = Math.floor(MAP_SIZE / 4 + Math.random() * (MAP_SIZE / 2));
        const y = Math.floor(MAP_SIZE / 4 + Math.random() * (MAP_SIZE / 2));
        
        // Prefer placing adjacent to roads for immediate connectivity
        if (isEmpty(x, y) && (isAdjacentToRoad(x, y) || attempt > 50)) {
          newPowerPlants.push({
            x,
            y,
            capacity: POWER_PLANT_CAPACITY,
            output: 0,
          });
          
          // Connect power plant to road network with power lines
          connectToRoad(x, y);
          
          // Also add power line on the power plant tile itself
          const tile = newTiles[y]?.[x];
          if (tile) {
            tile.hasPowerLine = true;
          }
          
          placed = true;
        }
      }
    }
    
    // 5. Place water pump(s) - 2-3 to ensure good coverage
    const waterPumpCount = 2 + Math.floor(Math.random() * 2); // 2-3 water pumps
    for (let i = 0; i < waterPumpCount; i++) {
      let placed = false;
      for (let attempt = 0; attempt < 100 && !placed; attempt++) {
        const x = Math.floor(Math.random() * MAP_SIZE);
        const y = Math.floor(Math.random() * MAP_SIZE);
        
        // Prefer placing adjacent to roads for immediate connectivity
        if (isEmpty(x, y) && 
            !newPowerPlants.some(pp => pp.x === x && pp.y === y) &&
            (isAdjacentToRoad(x, y) || attempt > 50)) {
          newWaterPumps.push({
            x,
            y,
            capacity: WATER_PUMP_CAPACITY,
          });
          
          // Connect water pump to road network with water pipes
          connectToRoad(x, y);
          
          // Also add water pipe on the water pump tile itself
          const tile = newTiles[y]?.[x];
          if (tile) {
            tile.hasWaterPipe = true;
          }
          
          placed = true;
        }
      }
    }
    
    // 6. Place police stations strategically in a grid pattern for even coverage
    // Police coverage radius is 8 tiles, so place every ~12 tiles for overlapping coverage
    // This ensures most of the map has police protection to prevent abandonment due to high crime
    const POLICE_GRID_SPACING = 12;
    let policeIndex = 0;
    
    for (let gridY = POLICE_GRID_SPACING / 2; gridY < MAP_SIZE; gridY += POLICE_GRID_SPACING) {
      for (let gridX = POLICE_GRID_SPACING / 2; gridX < MAP_SIZE; gridX += POLICE_GRID_SPACING) {
        // Find an empty spot near this grid position (search in expanding circles)
        let placed = false;
        
        for (let radius = 0; radius <= 4 && !placed; radius++) {
          for (let dy = -radius; dy <= radius && !placed; dy++) {
            for (let dx = -radius; dx <= radius && !placed; dx++) {
              // Only check positions on the perimeter of the current radius (or center for radius 0)
              if (radius > 0 && Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;
              
              const x = Math.floor(gridX) + dx;
              const y = Math.floor(gridY) + dy;
              
              if (isEmpty(x, y) && 
                  !newPowerPlants.some(pp => pp.x === x && pp.y === y) &&
                  !newWaterPumps.some(wp => wp.x === x && wp.y === y) &&
                  !newPoliceStations.some(ps => ps.position.gridX === x && ps.position.gridY === y)) {
                newPoliceStations.push({
                  id: `police_${x}_${y}_${Date.now()}_${policeIndex}`,
                  position: { gridX: x, gridY: y },
                });
                policeIndex++;
                placed = true;
              }
            }
          }
        }
      }
    }
    
    // 7. Set initial state WITH utilities but BEFORE zoning
    // This ensures calculatePowerGrid and calculateWaterGrid work correctly
    set({
      tiles: newTiles,
      powerPlants: newPowerPlants,
      waterPumps: newWaterPumps,
      policeStations: newPoliceStations,
      budget: 50000,
      isInitialized: true,
    });
    
    // 8. Calculate utility grids BEFORE zoning so zones know they have coverage
    get().calculatePowerGrid();
    get().calculateWaterGrid();
    
    // Re-fetch tiles after grid calculation to get updated isPowered/hasWaterService
    const updatedTiles = get().tiles;
    const zonedTiles = updatedTiles.map(row => row.map(tile => ({ ...tile })));
    
    // 9. Zone tiles adjacent to roads (now with utility coverage calculated)
    // Zone distribution: 65% Residential, 25% Commercial, 10% Industrial
    // Reduced industrial zones to lower overall crime generation (industrial generates 1.5x crime per job)
    const getRandomZoneType = (): ZoneType => {
      const rand = Math.random();
      if (rand < 0.65) return 'residential';
      if (rand < 0.90) return 'commercial';
      return 'industrial';
    };
    
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tile = zonedTiles[y]?.[x];
        if (!tile || tile.hasRoad || tile.zone !== null || tile.terrain === 'water') {
          continue;
        }
        
        // Check if adjacent to a road
        const adjacentCoords = [
          { ax: x, ay: y - 1 },
          { ax: x, ay: y + 1 },
          { ax: x - 1, ay: y },
          { ax: x + 1, ay: y },
        ];
        
        const hasAdjacentRoad = adjacentCoords.some(({ ax, ay }) => {
          if (ax < 0 || ax >= MAP_SIZE || ay < 0 || ay >= MAP_SIZE) return false;
          return zonedTiles[ay]?.[ax]?.hasRoad === true;
        });
        
        // Only zone tiles that have power AND water coverage (ensures development)
        const hasPower = tile.isPowered;
        const hasWater = tile.hasWaterService;
        
        if (hasAdjacentRoad && hasPower && hasWater && Math.random() < ZONE_CHANCE) {
          const zoneType = getRandomZoneType();
          tile.zone = zoneType;
          tile.zoneDensity = 'low';
          // Give zones some starting development progress for visual interest
          tile.developmentProgress = 50 + Math.floor(Math.random() * 50); // 50-100%
          
          // If fully developed, assign population/jobs
          if (tile.developmentProgress >= 100) {
            tile.developmentProgress = 100;
            if (zoneType === 'residential') {
              tile.population = 10 + Math.floor(Math.random() * 40);
            } else if (zoneType === 'commercial') {
              tile.jobs = 5 + Math.floor(Math.random() * 20);
            } else if (zoneType === 'industrial') {
              tile.jobs = 10 + Math.floor(Math.random() * 30);
            }
          }
        }
      }
    }
    
    // Calculate initial population and jobs
    let totalPopulation = 0;
    let totalCommercialJobs = 0;
    let totalIndustrialJobs = 0;
    
    for (let y = 0; y < MAP_SIZE; y++) {
      for (let x = 0; x < MAP_SIZE; x++) {
        const tile = zonedTiles[y]?.[x];
        if (tile && tile.developmentProgress >= 100) {
          if (tile.zone === 'residential') {
            totalPopulation += tile.population;
          } else if (tile.zone === 'commercial') {
            totalCommercialJobs += tile.jobs;
          } else if (tile.zone === 'industrial') {
            totalIndustrialJobs += tile.jobs;
          }
        }
      }
    }
    
    // 10. Set final state with zoned tiles
    set({
      tiles: zonedTiles,
      population: totalPopulation,
      commercialJobs: totalCommercialJobs,
      industrialJobs: totalIndustrialJobs,
    });
    
    // Final recalculation of all systems
    get().calculateCrime();
    get().calculatePollution();
    get().calculateDemand();
  },
}));
